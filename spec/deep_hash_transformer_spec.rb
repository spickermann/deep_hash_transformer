# frozen_string_literal: true

RSpec.describe DeepHashTransformer do
  subject(:transformer) { described_class.new(example) }

  describe 'autogenerated methods' do
    let(:example) { { foo: 'bar' } }

    DeepHashTransformer::TRANSFORMATIONS.each do |method|
      describe ".#{method}" do
        it "delegates to `KeyTransformer.#{method}`" do
          expect(
            DeepHashTransformer::KeyTransformer
          ).to receive(method).with(:foo).once # rubocop:disable RSpec/MessageSpies

          transformer.public_send(method)
        end
      end
    end
  end

  describe '#tr with `:snake_case, :symbolize`' do
    subject { super().tr(:snake_case, :symbolize) }

    let(:example) { { 'FooBar' => 'baz' } }

    it { expect(subject).to eq(foo_bar: 'baz') } # rubocop:disable RSpec/NamedSubject
  end

  describe '#tr with a complex, nested example' do
    subject { super().tr(:camel_case, :symbolize) }

    let(:example) do
      {
        Integer => 123,
        :symbol => { foo_bar: 'bar' },
        'string' => { 'foo_bar' => 123 },
        'nested-array' => [
          {
            'camelCased' => 'camelCased',
            'dashed-key' => 'dashed-key',
            'PascalCased' => 'PascalCased',
            'under_scored' => 'under_scored'
          }
        ]
      }
    end

    it do # rubocop:disable RSpec/ExampleLength
      expect(subject).to eq( # rubocop:disable RSpec/NamedSubject
        Integer => 123,
        :symbol => { fooBar: 'bar' },
        :string => { fooBar: 123 },
        :nestedArray => [
          {
            camelCased: 'camelCased',
            dashedKey: 'dashed-key',
            pascalCased: 'PascalCased',
            underScored: 'under_scored'
          }
        ]
      )
    end
  end

  it 'has a version number' do
    expect(DeepHashTransformer::VERSION).not_to be_nil
  end
end
